// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const appendRoleAccount = `-- name: AppendRoleAccount :one
INSERT INTO "AccountRole" (account, "role")
VALUES ($1, $2)
RETURNING account, role
`

type AppendRoleAccountParams struct {
	Account int32
	Role    string
}

func (q *Queries) AppendRoleAccount(ctx context.Context, arg AppendRoleAccountParams) (AccountRole, error) {
	row := q.db.QueryRowContext(ctx, appendRoleAccount, arg.Account, arg.Role)
	var i AccountRole
	err := row.Scan(&i.Account, &i.Role)
	return i, err
}

const appendTokenToBlackList = `-- name: AppendTokenToBlackList :exec
INSERT INTO "TokenBlackList" (token)
VALUES ($1)
`

func (q *Queries) AppendTokenToBlackList(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, appendTokenToBlackList, token)
	return err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO "Account" (username, "password", balance, deleted)
VALUES ($1, $2, $3, false)
RETURNING id, username, password, balance, deleted
`

type CreateAccountParams struct {
	Username string
	Password string
	Balance  float64
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount, arg.Username, arg.Password, arg.Balance)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Balance,
		&i.Deleted,
	)
	return i, err
}

const createRent = `-- name: CreateRent :one
INSERT INTO "Rent" (account, transport, time_start, time_end, price_unit, price_type, deleted)
VALUES ($1, $2, $3, $4, $5, $6, false)
RETURNING id, account, transport, time_start, time_end, price_unit, price_type, deleted
`

type CreateRentParams struct {
	Account   int32
	Transport int32
	TimeStart time.Time
	TimeEnd   sql.NullTime
	PriceUnit float64
	PriceType string
}

func (q *Queries) CreateRent(ctx context.Context, arg CreateRentParams) (Rent, error) {
	row := q.db.QueryRowContext(ctx, createRent,
		arg.Account,
		arg.Transport,
		arg.TimeStart,
		arg.TimeEnd,
		arg.PriceUnit,
		arg.PriceType,
	)
	var i Rent
	err := row.Scan(
		&i.ID,
		&i.Account,
		&i.Transport,
		&i.TimeStart,
		&i.TimeEnd,
		&i.PriceUnit,
		&i.PriceType,
		&i.Deleted,
	)
	return i, err
}

const createTransport = `-- name: CreateTransport :one
INSERT INTO "Transport"
(id, "owner", "type", can_rented, model, color, "description", identifier, latitude, longitude, minute_price, day_price, deleted)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, false)
RETURNING id, owner, type, can_rented, model, color, identifier, description, latitude, longitude, minute_price, day_price, deleted
`

type CreateTransportParams struct {
	ID          int32
	Owner       int32
	Type        string
	CanRented   bool
	Model       string
	Color       string
	Description sql.NullString
	Identifier  string
	Latitude    float64
	Longitude   float64
	MinutePrice sql.NullFloat64
	DayPrice    sql.NullFloat64
}

func (q *Queries) CreateTransport(ctx context.Context, arg CreateTransportParams) (Transport, error) {
	row := q.db.QueryRowContext(ctx, createTransport,
		arg.ID,
		arg.Owner,
		arg.Type,
		arg.CanRented,
		arg.Model,
		arg.Color,
		arg.Description,
		arg.Identifier,
		arg.Latitude,
		arg.Longitude,
		arg.MinutePrice,
		arg.DayPrice,
	)
	var i Transport
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Type,
		&i.CanRented,
		&i.Model,
		&i.Color,
		&i.Identifier,
		&i.Description,
		&i.Latitude,
		&i.Longitude,
		&i.MinutePrice,
		&i.DayPrice,
		&i.Deleted,
	)
	return i, err
}

const deleteAccountRoles = `-- name: DeleteAccountRoles :exec
DELETE
FROM "AccountRole"
WHERE account=$1
`

func (q *Queries) DeleteAccountRoles(ctx context.Context, account int32) error {
	_, err := q.db.ExecContext(ctx, deleteAccountRoles, account)
	return err
}

const endRent = `-- name: EndRent :exec
UPDATE "Rent"
SET time_end=$1
WHERE id=$2
`

type EndRentParams struct {
	TimeEnd sql.NullTime
	ID      int32
}

func (q *Queries) EndRent(ctx context.Context, arg EndRentParams) error {
	_, err := q.db.ExecContext(ctx, endRent, arg.TimeEnd, arg.ID)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, username, password, balance, deleted
FROM "Account"
WHERE id=$1
`

func (q *Queries) GetAccount(ctx context.Context, id int32) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Balance,
		&i.Deleted,
	)
	return i, err
}

const getAccountRoles = `-- name: GetAccountRoles :many
SELECT "role"
FROM "AccountRole"
WHERE account=$1
`

func (q *Queries) GetAccountRoles(ctx context.Context, account int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAccountRoles, account)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var role string
		if err := rows.Scan(&role); err != nil {
			return nil, err
		}
		items = append(items, role)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccounts = `-- name: GetAccounts :many
SELECT
    a.id, a.username, a.password, a.balance, a.deleted,
    json_agg(r.name) AS roles
FROM
    "Account" AS a
JOIN
    "AccountRole" AS ar ON a.id = ar.account
JOIN
    "Role" AS r ON ar.role = r.name
GROUP BY
    a.id
OFFSET $1 LIMIT $2
`

type GetAccountsParams struct {
	Offset int32
	Limit  int32
}

type GetAccountsRow struct {
	ID       int32
	Username string
	Password string
	Balance  float64
	Deleted  bool
	Roles    json.RawMessage
}

func (q *Queries) GetAccounts(ctx context.Context, arg GetAccountsParams) ([]GetAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccounts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsRow
	for rows.Next() {
		var i GetAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Balance,
			&i.Deleted,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCacheRoles = `-- name: GetCacheRoles :many
SELECT account, role
FROM "AccountRole"
`

func (q *Queries) GetCacheRoles(ctx context.Context) ([]AccountRole, error) {
	rows, err := q.db.QueryContext(ctx, getCacheRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountRole
	for rows.Next() {
		var i AccountRole
		if err := rows.Scan(&i.Account, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExistAccounts = `-- name: GetExistAccounts :many
SELECT
    a.id, a.username, a.password, a.balance, a.deleted,
    json_agg(r.name) AS roles
FROM
    "Account" AS a
JOIN
    "AccountRole" AS ar ON a.id = ar.account
JOIN
    "Role" AS r ON ar.role = r.name
WHERE
    a.deleted = false
GROUP BY
    a.id
OFFSET $1 LIMIT $2
`

type GetExistAccountsParams struct {
	Offset int32
	Limit  int32
}

type GetExistAccountsRow struct {
	ID       int32
	Username string
	Password string
	Balance  float64
	Deleted  bool
	Roles    json.RawMessage
}

func (q *Queries) GetExistAccounts(ctx context.Context, arg GetExistAccountsParams) ([]GetExistAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getExistAccounts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExistAccountsRow
	for rows.Next() {
		var i GetExistAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Balance,
			&i.Deleted,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRent = `-- name: GetRent :one
SELECT "Rent".id, account, transport, time_start, time_end, price_unit, price_type, "Rent".deleted, "Account".id, username, password, balance, "Account".deleted, "Transport".id, owner, type, can_rented, model, color, identifier, description, latitude, longitude, minute_price, day_price, "Transport".deleted
FROM "Rent"
JOIN "Account" ON "Rent".account = "Account".id
JOIN "Transport" ON "Rent".transport = "Transport".id
WHERE "Rent".id=$1
`

type GetRentRow struct {
	ID          int32
	Account     int32
	Transport   int32
	TimeStart   time.Time
	TimeEnd     sql.NullTime
	PriceUnit   float64
	PriceType   string
	Deleted     bool
	ID_2        int32
	Username    string
	Password    string
	Balance     float64
	Deleted_2   bool
	ID_3        int32
	Owner       int32
	Type        string
	CanRented   bool
	Model       string
	Color       string
	Identifier  string
	Description sql.NullString
	Latitude    float64
	Longitude   float64
	MinutePrice sql.NullFloat64
	DayPrice    sql.NullFloat64
	Deleted_3   bool
}

func (q *Queries) GetRent(ctx context.Context, id int32) (GetRentRow, error) {
	row := q.db.QueryRowContext(ctx, getRent, id)
	var i GetRentRow
	err := row.Scan(
		&i.ID,
		&i.Account,
		&i.Transport,
		&i.TimeStart,
		&i.TimeEnd,
		&i.PriceUnit,
		&i.PriceType,
		&i.Deleted,
		&i.ID_2,
		&i.Username,
		&i.Password,
		&i.Balance,
		&i.Deleted_2,
		&i.ID_3,
		&i.Owner,
		&i.Type,
		&i.CanRented,
		&i.Model,
		&i.Color,
		&i.Identifier,
		&i.Description,
		&i.Latitude,
		&i.Longitude,
		&i.MinutePrice,
		&i.DayPrice,
		&i.Deleted_3,
	)
	return i, err
}

const getRentsFromTransportID = `-- name: GetRentsFromTransportID :many
SELECT "Rent".id, account, transport, time_start, time_end, price_unit, price_type, "Rent".deleted, "Account".id, username, password, balance, "Account".deleted, "Transport".id, owner, type, can_rented, model, color, identifier, description, latitude, longitude, minute_price, day_price, "Transport".deleted
FROM "Rent"
JOIN "Account" ON "Rent".account = "Account".id
JOIN "Transport" ON "Rent".transport = "Transport".id
WHERE "Transport".id=$1
`

type GetRentsFromTransportIDRow struct {
	ID          int32
	Account     int32
	Transport   int32
	TimeStart   time.Time
	TimeEnd     sql.NullTime
	PriceUnit   float64
	PriceType   string
	Deleted     bool
	ID_2        int32
	Username    string
	Password    string
	Balance     float64
	Deleted_2   bool
	ID_3        int32
	Owner       int32
	Type        string
	CanRented   bool
	Model       string
	Color       string
	Identifier  string
	Description sql.NullString
	Latitude    float64
	Longitude   float64
	MinutePrice sql.NullFloat64
	DayPrice    sql.NullFloat64
	Deleted_3   bool
}

func (q *Queries) GetRentsFromTransportID(ctx context.Context, id int32) ([]GetRentsFromTransportIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getRentsFromTransportID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRentsFromTransportIDRow
	for rows.Next() {
		var i GetRentsFromTransportIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Account,
			&i.Transport,
			&i.TimeStart,
			&i.TimeEnd,
			&i.PriceUnit,
			&i.PriceType,
			&i.Deleted,
			&i.ID_2,
			&i.Username,
			&i.Password,
			&i.Balance,
			&i.Deleted_2,
			&i.ID_3,
			&i.Owner,
			&i.Type,
			&i.CanRented,
			&i.Model,
			&i.Color,
			&i.Identifier,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.MinutePrice,
			&i.DayPrice,
			&i.Deleted_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRentsFromUsername = `-- name: GetRentsFromUsername :many
SELECT "Rent".id, account, transport, time_start, time_end, price_unit, price_type, "Rent".deleted, "Account".id, username, password, balance, "Account".deleted, "Transport".id, owner, type, can_rented, model, color, identifier, description, latitude, longitude, minute_price, day_price, "Transport".deleted
FROM "Rent"
JOIN "Account" ON "Rent".account = "Account".id
JOIN "Transport" ON "Rent".transport = "Transport".id
WHERE "Account".username=$1
`

type GetRentsFromUsernameRow struct {
	ID          int32
	Account     int32
	Transport   int32
	TimeStart   time.Time
	TimeEnd     sql.NullTime
	PriceUnit   float64
	PriceType   string
	Deleted     bool
	ID_2        int32
	Username    string
	Password    string
	Balance     float64
	Deleted_2   bool
	ID_3        int32
	Owner       int32
	Type        string
	CanRented   bool
	Model       string
	Color       string
	Identifier  string
	Description sql.NullString
	Latitude    float64
	Longitude   float64
	MinutePrice sql.NullFloat64
	DayPrice    sql.NullFloat64
	Deleted_3   bool
}

func (q *Queries) GetRentsFromUsername(ctx context.Context, username string) ([]GetRentsFromUsernameRow, error) {
	rows, err := q.db.QueryContext(ctx, getRentsFromUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRentsFromUsernameRow
	for rows.Next() {
		var i GetRentsFromUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Account,
			&i.Transport,
			&i.TimeStart,
			&i.TimeEnd,
			&i.PriceUnit,
			&i.PriceType,
			&i.Deleted,
			&i.ID_2,
			&i.Username,
			&i.Password,
			&i.Balance,
			&i.Deleted_2,
			&i.ID_3,
			&i.Owner,
			&i.Type,
			&i.CanRented,
			&i.Model,
			&i.Color,
			&i.Identifier,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.MinutePrice,
			&i.DayPrice,
			&i.Deleted_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransport = `-- name: GetTransport :one
SELECT id, owner, type, can_rented, model, color, identifier, description, latitude, longitude, minute_price, day_price, deleted
FROM "Transport"
WHERE id=$1
`

func (q *Queries) GetTransport(ctx context.Context, id int32) (Transport, error) {
	row := q.db.QueryRowContext(ctx, getTransport, id)
	var i Transport
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Type,
		&i.CanRented,
		&i.Model,
		&i.Color,
		&i.Identifier,
		&i.Description,
		&i.Latitude,
		&i.Longitude,
		&i.MinutePrice,
		&i.DayPrice,
		&i.Deleted,
	)
	return i, err
}

const getTransports = `-- name: GetTransports :many
SELECT id, owner, type, can_rented, model, color, identifier, description, latitude, longitude, minute_price, day_price, deleted
FROM "Transport"
ORDER BY id
OFFSET $1 LIMIT $2
`

type GetTransportsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetTransports(ctx context.Context, arg GetTransportsParams) ([]Transport, error) {
	rows, err := q.db.QueryContext(ctx, getTransports, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transport
	for rows.Next() {
		var i Transport
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Type,
			&i.CanRented,
			&i.Model,
			&i.Color,
			&i.Identifier,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.MinutePrice,
			&i.DayPrice,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransportsFromRadiusAll = `-- name: GetTransportsFromRadiusAll :many
SELECT id, owner, type, can_rented, model, color, identifier, description, latitude, longitude, minute_price, day_price, deleted
FROM "Transport"
WHERE
    "can_ranted"=true and
    (6371000 * ACOS(SIN(RADIANS($1)) * SIN(RADIANS("latitude")) + COS(RADIANS($1)) * COS(RADIANS("latitude")) * COS(RADIANS("longitude" - $2)))) <= $3
`

type GetTransportsFromRadiusAllParams struct {
	Radians   float64
	Longitude float64
	Latitude  float64
}

func (q *Queries) GetTransportsFromRadiusAll(ctx context.Context, arg GetTransportsFromRadiusAllParams) ([]Transport, error) {
	rows, err := q.db.QueryContext(ctx, getTransportsFromRadiusAll, arg.Radians, arg.Longitude, arg.Latitude)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transport
	for rows.Next() {
		var i Transport
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Type,
			&i.CanRented,
			&i.Model,
			&i.Color,
			&i.Identifier,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.MinutePrice,
			&i.DayPrice,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransportsFromRadiusOnlyType = `-- name: GetTransportsFromRadiusOnlyType :many
SELECT id, owner, type, can_rented, model, color, identifier, description, latitude, longitude, minute_price, day_price, deleted
FROM "Transport"
WHERE
    "can_ranted"=true and
    "type"=$1 and
    (6371000 * ACOS(SIN(RADIANS($2)) * SIN(RADIANS("latitude")) + COS(RADIANS($2)) * COS(RADIANS("latitude")) * COS(RADIANS("longitude" - $3)))) <= $4
`

type GetTransportsFromRadiusOnlyTypeParams struct {
	Type      string
	Radians   float64
	Longitude float64
	Latitude  float64
}

func (q *Queries) GetTransportsFromRadiusOnlyType(ctx context.Context, arg GetTransportsFromRadiusOnlyTypeParams) ([]Transport, error) {
	rows, err := q.db.QueryContext(ctx, getTransportsFromRadiusOnlyType,
		arg.Type,
		arg.Radians,
		arg.Longitude,
		arg.Latitude,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transport
	for rows.Next() {
		var i Transport
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Type,
			&i.CanRented,
			&i.Model,
			&i.Color,
			&i.Identifier,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.MinutePrice,
			&i.DayPrice,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransportsOnlyType = `-- name: GetTransportsOnlyType :many
SELECT id, owner, type, can_rented, model, color, identifier, description, latitude, longitude, minute_price, day_price, deleted
FROM "Transport"
WHERE "type"=$1
ORDER BY id
OFFSET $2 LIMIT $3
`

type GetTransportsOnlyTypeParams struct {
	Type   string
	Offset int32
	Limit  int32
}

func (q *Queries) GetTransportsOnlyType(ctx context.Context, arg GetTransportsOnlyTypeParams) ([]Transport, error) {
	rows, err := q.db.QueryContext(ctx, getTransportsOnlyType, arg.Type, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transport
	for rows.Next() {
		var i Transport
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Type,
			&i.CanRented,
			&i.Model,
			&i.Color,
			&i.Identifier,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.MinutePrice,
			&i.DayPrice,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isAccountExist = `-- name: IsAccountExist :one
SELECT EXISTS (
  SELECT 1
  FROM "Account"
  WHERE id=$1
)
`

func (q *Queries) IsAccountExist(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, isAccountExist, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isAccountRemoved = `-- name: IsAccountRemoved :one
SELECT EXISTS (
  SELECT 1
  FROM "Account"
  WHERE id=$1 and deleted=true
)
`

func (q *Queries) IsAccountRemoved(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, isAccountRemoved, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isContainBlackListToken = `-- name: IsContainBlackListToken :one
SELECT EXISTS (
  SELECT 1
  FROM "TokenBlackList"
  WHERE token=$1
)
`

func (q *Queries) IsContainBlackListToken(ctx context.Context, token string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isContainBlackListToken, token)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isExistCurrentRent = `-- name: IsExistCurrentRent :one
SELECT EXISTS (
    SELECT 1
    FROM "Rent"
    WHERE transport=$1 and time_end=null
)
`

func (q *Queries) IsExistCurrentRent(ctx context.Context, transport int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, isExistCurrentRent, transport)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isExistTransport = `-- name: IsExistTransport :one
SELECT EXISTS (
  SELECT 1
  FROM "Transport"
  WHERE id=$1
)
`

func (q *Queries) IsExistTransport(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, isExistTransport, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isRentExist = `-- name: IsRentExist :one
SELECT EXISTS (
  SELECT 1
  FROM "Rent"
  WHERE id=$1
)
`

func (q *Queries) IsRentExist(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, isRentExist, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isRentRemoved = `-- name: IsRentRemoved :one
SELECT EXISTS (
  SELECT 1
  FROM "Rent"
  WHERE id=$1 and deleted=true
)
`

func (q *Queries) IsRentRemoved(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, isRentRemoved, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isRenter = `-- name: IsRenter :one
SELECT EXISTS (
  SELECT 1
  FROM "Rent"
  WHERE id=$1 and account=$2
)
`

type IsRenterParams struct {
	ID      int32
	Account int32
}

func (q *Queries) IsRenter(ctx context.Context, arg IsRenterParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isRenter, arg.ID, arg.Account)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isTransportOwner = `-- name: IsTransportOwner :one
SELECT EXISTS (
  SELECT 1
  FROM "Transport"
  WHERE id=$1 and "owner"=$2
)
`

type IsTransportOwnerParams struct {
	ID    int32
	Owner int32
}

func (q *Queries) IsTransportOwner(ctx context.Context, arg IsTransportOwnerParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isTransportOwner, arg.ID, arg.Owner)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isTransportRemoved = `-- name: IsTransportRemoved :one
SELECT EXISTS (
  SELECT 1
  FROM "Transport"
  WHERE id=$1 and deleted=true
)
`

func (q *Queries) IsTransportRemoved(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, isTransportRemoved, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const removeAccount = `-- name: RemoveAccount :exec
UPDATE "Account"
SET deleted=true
WHERE id=$1
`

func (q *Queries) RemoveAccount(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, removeAccount, id)
	return err
}

const removeTransport = `-- name: RemoveTransport :exec
UPDATE "Transport"
SET deleted=true
WHERE id=$1
`

func (q *Queries) RemoveTransport(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, removeTransport, id)
	return err
}

const replaceUsername = `-- name: ReplaceUsername :exec
UPDATE "Account"
SET username=$1
WHERE id=$2
`

type ReplaceUsernameParams struct {
	Username string
	ID       int32
}

func (q *Queries) ReplaceUsername(ctx context.Context, arg ReplaceUsernameParams) error {
	_, err := q.db.ExecContext(ctx, replaceUsername, arg.Username, arg.ID)
	return err
}

const updateAccount = `-- name: UpdateAccount :exec
UPDATE "Account"
SET username=$1, "password"=$2, balance=$3
WHERE id=$4
`

type UpdateAccountParams struct {
	Username string
	Password string
	Balance  float64
	ID       int32
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) error {
	_, err := q.db.ExecContext(ctx, updateAccount,
		arg.Username,
		arg.Password,
		arg.Balance,
		arg.ID,
	)
	return err
}

const updateTransport = `-- name: UpdateTransport :one
UPDATE "Transport"
SET id=$1, can_rented=$2, model=$3, color=$4, "description"=$5, latitude=$6, longitude=$7, minute_price=$8, day_price=$9, identifier=$10
WHERE id=$11
RETURNING id, owner, type, can_rented, model, color, identifier, description, latitude, longitude, minute_price, day_price, deleted
`

type UpdateTransportParams struct {
	ID          int32
	CanRented   bool
	Model       string
	Color       string
	Description sql.NullString
	Latitude    float64
	Longitude   float64
	MinutePrice sql.NullFloat64
	DayPrice    sql.NullFloat64
	Identifier  string
	ID_2        int32
}

func (q *Queries) UpdateTransport(ctx context.Context, arg UpdateTransportParams) (Transport, error) {
	row := q.db.QueryRowContext(ctx, updateTransport,
		arg.ID,
		arg.CanRented,
		arg.Model,
		arg.Color,
		arg.Description,
		arg.Latitude,
		arg.Longitude,
		arg.MinutePrice,
		arg.DayPrice,
		arg.Identifier,
		arg.ID_2,
	)
	var i Transport
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Type,
		&i.CanRented,
		&i.Model,
		&i.Color,
		&i.Identifier,
		&i.Description,
		&i.Latitude,
		&i.Longitude,
		&i.MinutePrice,
		&i.DayPrice,
		&i.Deleted,
	)
	return i, err
}
